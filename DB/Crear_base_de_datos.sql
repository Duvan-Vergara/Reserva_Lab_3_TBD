CREATE DATABASE "tbd2";

\c tbd2;
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS postgis_topology;

CREATE TABLE CLIENTE (
  id_cliente BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre     VARCHAR(255) NOT NULL,
  direccion  VARCHAR(255) NOT NULL,
  correo     VARCHAR(100) NOT NULL UNIQUE,
  password   VARCHAR(255) NOT NULL,
  deleted_at DATE,
  ubicacion_cliente GEOMETRY(POINT, 4326) NOT NULL
);

CREATE TABLE EMPRESA_ASOCIADA (
  id_empresa_asociada INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL,
  ubicacion_empresa_asociada GEOMETRY(POINT, 4326) NOT NULL
);

CREATE TABLE DETALLE_PEDIDO (
  id_detalle_pedido BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  entregado BOOLEAN NOT NULL,
  hora_entrega TIMESTAMP,
  calificacion NUMERIC(4,2)
);

CREATE TABLE MEDIO_PAGO (
  id_medio_pago INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo VARCHAR(50) NOT NULL
);

CREATE TABLE CATEGORIA (
  id_categoria INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL
);

CREATE TABLE URGENCIA (
  id_urgencia INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo VARCHAR(50) NOT NULL
);

CREATE TABLE REPARTIDOR (
  id_repartidor INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL,
  id_empresa_asociada INT NOT NULL,
  deleted_at DATE,
  ubicacion_repartidor GEOMETRY(POINT, 4326) NOT NULL,
  distancia_recorrida DECIMAL(10,2) NOT NULL,
  FOREIGN KEY (id_empresa_asociada) REFERENCES EMPRESA_ASOCIADA(id_empresa_asociada) ON DELETE CASCADE
);

CREATE TABLE PRODUCTO_SERVICIO (
  id_producto_servicio INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  stock INT NOT NULL,
  precio DECIMAL(10,2) NOT NULL,
  id_categoria INT NOT NULL,
  id_empresa_asociada INT NOT NULL,
  es_producto BOOLEAN NOT NULL DEFAULT TRUE,
  FOREIGN KEY (id_categoria) REFERENCES CATEGORIA(id_categoria) ON DELETE CASCADE,
  FOREIGN KEY (id_empresa_asociada) REFERENCES EMPRESA_ASOCIADA(id_empresa_asociada) ON DELETE CASCADE
);

CREATE TABLE PEDIDO (
  id_pedido BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  hora_pedido TIMESTAMP NOT NULL,
  id_urgencia INT NOT NULL,
  id_detalle_pedido INT NOT NULL,
  id_repartidor INT NOT NULL,
  id_cliente INT NOT NULL,
  id_medio_pago INT NOT NULL,
  deleted_at DATE,
  ubicacion_entrega GEOMETRY(POINT, 4326) NOT NULL,
  ruta_estimada GEOMETRY(LineString, 4326) NOT NULL,
  FOREIGN KEY (id_urgencia) REFERENCES URGENCIA(id_urgencia) ON DELETE CASCADE,
  FOREIGN KEY (id_detalle_pedido) REFERENCES DETALLE_PEDIDO(id_detalle_pedido) ON DELETE CASCADE,
  FOREIGN KEY (id_repartidor) REFERENCES REPARTIDOR(id_repartidor) ON DELETE CASCADE,
  FOREIGN KEY (id_cliente) REFERENCES CLIENTE(id_cliente) ON DELETE CASCADE,
  FOREIGN KEY (id_medio_pago) REFERENCES MEDIO_PAGO(id_medio_pago) ON DELETE CASCADE
);

CREATE TABLE CALIFICACION (
  id_calificacion INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  total_puntos    INT  NOT NULL,
  total_pedidos   INT  NOT NULL,
  promedio        NUMERIC(4,2) NOT NULL,
  id_repartidor   INT  NOT NULL UNIQUE,
  FOREIGN KEY (id_repartidor) REFERENCES REPARTIDOR(id_repartidor) ON DELETE CASCADE
);

CREATE TABLE NOTIFICACION (
  id_notificacion INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_pedido INT NOT NULL,
  mensaje VARCHAR(255) NOT NULL,
  FOREIGN KEY (id_pedido) REFERENCES PEDIDO(id_pedido) ON DELETE CASCADE
);

-- Tabla de relación entre pedidos y productos/servicios
CREATE TABLE PEDIDO_PRODUCTO (
  id_pedido INT NOT NULL,
  id_producto_servicio INT NOT NULL,
  cantidad INT NOT NULL,
  PRIMARY KEY (id_pedido, id_producto_servicio),
  FOREIGN KEY (id_pedido) REFERENCES PEDIDO(id_pedido),
  FOREIGN KEY (id_producto_servicio) REFERENCES PRODUCTO_SERVICIO(id_producto_servicio) ON DELETE CASCADE
);

CREATE TABLE ZONA_COBERTURA (
  id_zona SERIAL PRIMARY KEY,
  nombre VARCHAR(255) NOT NULL,
  tipo VARCHAR(50) NOT NULL,
  zona_geom GEOMETRY(POLYGON, 4326) NOT NULL
);

CREATE TABLE EMPRESA_ZONA (
  id_empresa_zona BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_empresa_asociada INT NOT NULL,
  id_zona INT NOT NULL,
  FOREIGN KEY (id_empresa_asociada) REFERENCES EMPRESA_ASOCIADA(id_empresa_asociada) ON DELETE CASCADE,
  FOREIGN KEY (id_zona) REFERENCES ZONA_COBERTURA(id_zona) ON DELETE CASCADE
);

CREATE TABLE PUNTO_INTERES (
  id SERIAL PRIMARY KEY,
  nombre VARCHAR(100),
  tipo VARCHAR(50), 
  ubicacion GEOGRAPHY(POINT, 4326)
);

-- Funciones y triggers

CREATE OR REPLACE FUNCTION fn_notificar_error_pedido()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.hora_pedido IS NULL THEN
    RAISE EXCEPTION 'Error: La hora del pedido no puede ser NULL.';
  END IF;
  IF NEW.id_urgencia IS NULL THEN
    RAISE EXCEPTION 'Error: La urgencia del pedido no puede ser NULL.';
  END IF;
  IF NEW.id_detalle_pedido IS NULL THEN
    RAISE EXCEPTION 'Error: El detalle del pedido no puede ser NULL.';
  END IF;
  IF NEW.id_repartidor IS NULL THEN
    RAISE EXCEPTION 'Error: El repartidor del pedido no puede ser NULL.';
  END IF;
  IF NEW.id_cliente IS NULL THEN
    RAISE EXCEPTION 'Error: El cliente del pedido no puede ser NULL.';
  END IF;
  IF NEW.id_medio_pago IS NULL THEN
    RAISE EXCEPTION 'Error: El medio de pago del pedido no puede ser NULL.';
  END IF;
  IF NEW.id_pedido IS NULL THEN
    RAISE EXCEPTION 'Error: El ID del pedido no puede ser NULL.';
  END IF;

  IF NEW.id_urgencia NOT IN (SELECT id_urgencia FROM URGENCIA) THEN
    RAISE EXCEPTION 'Error: La urgencia del pedido no es válida.';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER notificar_error_pedido
AFTER INSERT ON PEDIDO
FOR EACH ROW
EXECUTE PROCEDURE fn_notificar_error_pedido();

CREATE OR REPLACE FUNCTION set_hora_entrega()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.entregado = TRUE AND OLD.entregado = FALSE THEN
    NEW.hora_entrega := CURRENT_TIMESTAMP;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER a_trigger_hora_entrega
BEFORE UPDATE ON DETALLE_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION set_hora_entrega();

CREATE OR REPLACE FUNCTION fn_actualizar_promedio_repartidor()
RETURNS TRIGGER AS $$
DECLARE
  v_repartidor INT;
  v_delta      INT;
BEGIN
  SELECT p.id_repartidor
  INTO   v_repartidor
  FROM   PEDIDO p
  WHERE  p.id_detalle_pedido = NEW.id_detalle_pedido;

  IF v_repartidor IS NULL THEN
    RAISE EXCEPTION 'Pedido no encontrado para detalle %', NEW.id_detalle_pedido;
  END IF;

  IF TG_OP = 'INSERT' THEN
    INSERT INTO CALIFICACION (id_repartidor, total_puntos, total_pedidos, promedio)
    VALUES (v_repartidor, NEW.calificacion, 1, NEW.calificacion::NUMERIC)
    ON CONFLICT (id_repartidor) DO
      UPDATE
      SET total_puntos  = CALIFICACION.total_puntos  + EXCLUDED.total_puntos,
          total_pedidos = CALIFICACION.total_pedidos + 1,
          promedio      = (CALIFICACION.total_puntos + EXCLUDED.total_puntos)::NUMERIC
                          / (CALIFICACION.total_pedidos + 1);

  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.calificacion IS DISTINCT FROM OLD.calificacion THEN
      v_delta := NEW.calificacion - COALESCE(OLD.calificacion, 0);

      UPDATE CALIFICACION
      SET total_puntos  = total_puntos + v_delta,
          total_pedidos = total_pedidos
                          + CASE
                              WHEN OLD.calificacion IS NULL AND NEW.calificacion IS NOT NULL THEN 1
                              WHEN OLD.calificacion IS NOT NULL AND NEW.calificacion IS NULL THEN -1
                              ELSE 0
                            END,
          promedio      = CASE
                            WHEN total_pedidos
                                   + CASE
                                       WHEN OLD.calificacion IS NULL AND NEW.calificacion IS NOT NULL THEN 1
                                       WHEN OLD.calificacion IS NOT NULL AND NEW.calificacion IS NULL THEN -1
                                       ELSE 0
                                     END > 0
                            THEN (total_puntos + v_delta)::NUMERIC
                                 / (total_pedidos
                                    + CASE
                                        WHEN OLD.calificacion IS NULL AND NEW.calificacion IS NOT NULL THEN 1
                                        WHEN OLD.calificacion IS NOT NULL AND NEW.calificacion IS NULL THEN -1
                                        ELSE 0
                                      END)
                            ELSE NULL
                          END
      WHERE id_repartidor = v_repartidor;
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calif_insert
AFTER INSERT ON DETALLE_PEDIDO
FOR EACH ROW
WHEN (NEW.calificacion IS NOT NULL)
EXECUTE FUNCTION fn_actualizar_promedio_repartidor();

CREATE TRIGGER trg_calif_update
AFTER UPDATE OF calificacion ON DETALLE_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION fn_actualizar_promedio_repartidor();

CREATE OR REPLACE FUNCTION fn_calif_retraso_48h()
RETURNS TRIGGER AS $$
DECLARE
  v_hora_pedido TIMESTAMP;
BEGIN
  SELECT hora_pedido
  INTO   v_hora_pedido
  FROM   PEDIDO
  WHERE  id_detalle_pedido = NEW.id_detalle_pedido;

  IF v_hora_pedido IS NOT NULL
     AND NEW.entregado = TRUE
     AND NEW.calificacion IS NULL
     AND NEW.hora_entrega IS NOT NULL
     AND NEW.hora_entrega >= v_hora_pedido + INTERVAL '48 hours' THEN
     NEW.calificacion := 1;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_calif_retraso_48h
BEFORE UPDATE ON DETALLE_PEDIDO
FOR EACH ROW
EXECUTE FUNCTION fn_calif_retraso_48h();